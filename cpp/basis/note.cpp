/**
 *  ----- 静态  ------
 * ->静态数据成员不依赖于对象而存在，依赖于类，仅此一份。
 * ->静态成员，不必实例化就是存在的。
 * ->不能在构造函数中实例化，静态数据成员必须单独初始化。
 * =======
 * 访问方法：
 * -> 直接通过类来访问静态的成员函数。
 * -> 对象点号访问方式。
 * 
 * ++++++++++
 * => 静态成员必须单独初始化。（与类一起，不与对象一起产生）
 * => 静态成员函数不能调用非静态成员函数和非静态数据成员
 * => 非静态成员函数可以调用静态成员函数和静态数据成员
 * => 静态数据成员只有一份，且不依赖对象而存在
 * => sizeof求对象的大小，不会包含静态数据成员大小。


 * 
*/

/**
 * Run-Time Type Identification
*/

/**
 * dynamic_cast注意事项：
 * -> 只能应用于指针和引用的转换
 * -> 要转换的类型中必须包含虚函数
 * -> 转换成功返回子类的地址，失败返回NULL
 * 
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * 
 * typeid注意事项：
 * -> type_id返回一个type_info对象的引用
 * -> 如果想通过基类的指针获得派生类的数据类型,基类必须带有虚函数
 * -> 只能获取对象的实际类型。(不能判断当前指针是基类还是子类)
*/

/**
 * 继承关系不是RTTI的充分条件，只是必要条件，所以存在继承关系的类不一定可以用RTTI技术
 * => RTTI的含义是运行时类型识别
 * => RTTI技术可以通过父类指针识别其所指向对象的真实数据类型
 * => 运行时类型别必须建立在虚函数的基础上，否则无需RTTI技术
 * 
*/

/**
 * 接口类
 * -> 含有纯虚函数的类叫抽象类；仅含有纯虚函数的类叫接口类
 * -> 接口类没有数据成员，只有成员函数，仅有的成员函数还全部都是纯虚函数
 * 
 * ++++++++++++++++++++++++++++
 * 接口类表达的是一种能力或协议
 * 
*/


/**
 * 纯虚函数：
 * ->没有函数体
 * ->直接等于0
 * ------------------------------------
 * 当我们定义了一个纯虚函数，他同样会在虚函数表中出现，
 * 他的值是0（意思就是他没有指向代码区，不会实现任何方法）。
 * 他这样的目的是为了让子类在继承他的时候，再实现他的方法。!!!!!!!!!!!!!!!!!!!!
 * 
 * ========================================
 * !! 在虚函数表中直接写为0，
 * !! 包含纯虚函数的类，就是抽象类。上面含有纯虚函数的shape类就是一个抽象类。
 * !! 纯虚函数无法调用，所以抽象类无法实例化对象 !!!!!!!!!!!!!1
*/

/**
 * >>> 包含纯虚函数的类，就是抽象类。<<<
 * => 抽象类的子类也有可能是抽象类。
 * => 抽象类的子类只有把抽象类当中的所有纯虚函数都做了实现，子类才可以实例化对象。
*/


/**
 * 函数的本质就是一段二进制的代码，指针指向代码的开头，然后一行一行执行到函数结尾
*/

/**
 * 当我们实例化一个对象时,对象中除了数据成员,
 * 还有另外一个成员(虚函数表指针;也是一个指针占有四个内存单元,存放地址,指向一个虚函数表)。
 * 该表会与类的定义同时出现，在计算机中虚函数表占有一定内存空间。
*/
/**
 * 子类会继承父类的虚函数
*/


/**
 * 父类和子类出现同名函数，称之为函数隐藏。
 * ->如果没有在子类中定义同名虚函数，那么子类的虚函数表指针会写上父类函数的地址.
 * ->如果在子类中也定义了同名的虚函数，那么将覆盖父类的函数指针指向子类的函数。
*/

